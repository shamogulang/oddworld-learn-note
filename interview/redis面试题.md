## 1、redis为什么快

- 基于内存操作

- 单线程避免了线程的上下文切换

- io多路复用

  

## 2、redis的基本数据结构

- string
- hash
- set
- list
- zset



## 3、redis缓存雪崩、击穿、穿透是什么

- 缓存雪崩

  ```java
     缓存雪崩的是指一大片的缓存在同一时间失效，导致请求大量落到数据库。如果出现这种问题，请求量过大的话，数据库有可能会崩溃，导致服务异常。
  
     对key的过期时间加一个随机值，防止所有的key统一时间过期。
  ```

- 击穿

  ```
     击穿是指某个hot key过期了，突然大量的请求过来，都请求到数据库了，这也可能导致数据库压力过大崩溃，导致服务异常。
  
     hot key永不过期或者对数据库的访问加锁防止请求一股脑都落到数据库。
  ```

- 穿透

  ```
     穿透数据库中不存在的key，导致每次都请求到数据库，导致服务的压力过大，然后导致崩溃。
  
     进行参数检验，不合法的参数直接抛异常返回，防止请求到数据库。或者对不合法的key加入缓存，设个短的过期时间，或者使用布隆过滤器。
  ```

  

## 4、redis的淘汰策略

- 永不过期，不够内存直接抛出异常
- 所有key随机淘汰
- 已过期的key中随机淘汰
- 所有的key最近最少使用的淘汰
- 过期的key中最近最少使用淘汰
- 从设置了过期时间的数据中，将要过期的数据淘汰。



## 5、redis分布式锁

```
set nx 进行分布式锁的设置。如果由key，那么返回false,如果没有key，就设置key,同时返回true
这里的设置和过期时间在redis中由原子性的操作，防止设置了key，但是没有设置过期时间，导致程序出现异常的时候，key永远不过期，从而出现问题。
对于程序中如果业务代码太过长，定时的任务在上一次任务完成之前又执行的话，可以使用redission中的看门狗机制，默认的过期时间是30秒，每隔10秒都会对锁续期。从而防止业务代码处理时间较长的问题。
不可重入问题，也是使用redission。
主从同步复制延时的问题，使用红锁。
```



## 6、redis过期key的删除机制

- 惰性删除

  ```
  惰性删除的意思是key过期后直到查这个key的时候才去删除它。这种方式可以节省cpu的销毁，但是会比较浪费内存，因为这些key是过期的，却还是存在内存里。
  ```

  

- 定期删除

  ```
  定期删除是没隔一段时间就会去检查过期的key，然乎删除，检查清理key的过程会占用一部分cpu,过期的key在一定时间内，也会被移除内存，在一定程度上优化了内存的空间。
  ```

  

- 定时删除

  ```
  创建一个定时器，由当定时器到期了，就主动去删除对应的过期key。这一种策略能快速释放内存，最节省内存，但是对cpu的压力也是最大的。
  ```

  



## 7、如何保证redis和数据库的一致性

- 先删缓存，再更新数据库

  ```
  先删除缓存，然后更新数据库，有可能会在更新数据库完成之前，又有其他的线程过来，此时会发现缓存中没有数据，就先去数据库查数据 ，然后更新到缓存。那么此时的缓存就是脏数据。
  ```

  - 方案1： 延时双删：先删除缓存，然后更新数据库，更新完数据库后休眠一段时间再删除缓存。如果写操作比较频繁，那么脏数据的问题还是可能会比较严重，引入延时的时间内，数据有可能都是脏数据。

    

- 先更新数据库，再删除缓存

  ```
  先更新数据库，然后删除缓存，有可能过期缓存删除失败。那么数据就是脏数据了。
  ```

  - 方案1：给缓存一个过期时间。 但是过期时间内有可能都是脏数据。
  - 方案2：可以让失败的操作重试几次，多次失败后记录日志做补偿。
  - 方案3：引入MQ，删除失败的进入MQ，通过mq来删除缓存。

 

## 8、redis主从复制的过程

​         从服务器收到slaveof命令，如果是第一次同步，会向master发送pysnc命令，master收到后将runid和offset也给到从服务器。 同时fork一个子进程，执行bgsave生成RBD的快照，然后将快照发送给从服务器，在bgsave的过程中，会开辟一个缓冲区于记录后续的写命令。从服务器就记录这个runid和offset。从服务器接收到RDB文件，执行导入的时候会先清空数据再执行。如果不是第一次同步，那么从服务器会psync+runid+offset给到master,master根据这个runid和offset来决定是否进行部分复制，如果不满足相关条件，就会触发全量复制，满足条件就会执行部分复制。

- 全量复制

  ```
  第一次进行同步，采用的是全量复制的方式，如果发现runid不一致了，也采用全量复制的方式。
  
  runid+psync=-1进行全量复制
  
  从节点向主节点发送psysnc请求，主节点接受到请求后，执行bgsave操作，fork一个子进程去生成RDB文件，该过程会比较消耗cpu。
  然后将这个文件通过网络传送给从节点，此过程会消耗网络带宽。
  从节点接受到文件后，先清空数据，载入RDB文件，这个过程从节点无法响应客户端的命令。
  ```

  

- 部分复制

  ```
  当offset的大小大于缓冲区，说明缓存区由数据丢失，此时只能进行全量复制
  当从节点记录的主节点runid和当前通信的主节点runid不同的时候，说明没有复制过，所以也只能进行全量复制。
  
  主从节点都会维护一个偏移量offset，从节点通过偏移量和runid请求主节点，
  主节点内部维护了一个固定长度的，先进先出的FIFO队列作为缓存区。如果偏移量在这个缓冲区内，那么就会进行部分复制。
  ```



## 9、布隆过滤器的原理

```
布隆过滤器使用bite位来存储是否存在某个值。一个int是4个字节，那么就是32位。那么就是要存2000000000（20亿）的数据，只需要占用内存：238M的内存。
对一个值，可以是一个url或者其他任意字符串，经过一个hash函数的得到一个值，设置对应的布隆过滤器，那么下次要访问这个值的时候，即可知道这个值是否在这个过滤器中。

为了减少碰撞，可以使用多个hash函数，然后设置多个位置。
如果一个值经过多个hash函数，发现只要任意一个位置是0，那么这个值就一定不在这个过滤器中。
但是如果一个值发现都为1，那么这个值不一定在这个过滤器中，因为可能是其他key的导致的值为1。
```



## 10、如何查redis的慢查询

```
config get/set slowlog-log-slower-than   单位微妙：执行的时间大于该值的数据，会进入该队列

config get slowlog-max-len   默认的队列的大小，当队列满了，再有日志进来的话，会丢弃最先入队的数据。

查看慢日志：  slowlog get即可查询得到
```



## 11、 redis的高可用方案

- 主从

  ```
  一台redis存在单点故障问题，如果需要备用节点，进行数据的备份，那么需要进行主从，这样子就可以将数据备份起来，可以一主一从，或者是一主多从。
  
  缺点：这种模式，如果出现故障，需要手动干预才能让集群正常使用
  ```

  

- 哨兵

  ```
  为了解决上述需要手动干预进行故障转移，可以使用哨兵机制，redis的哨兵机制可以主动进行故障的转移，如果主master被确认下线后，可以升其中一个节点为主节点，进行故障的转移。同时引入的哨兵也可以进行集群部署。
  
  缺点： 这个只能一主多从，扩展读的压力，如果写入的访问量很多的话，就需要多主多从。
  ```

  

- redis sharding

  ```
  这个是客户端分片的机制，就是说，redis的多台实例是彼此没关系的，需要进行redis操作的时候，就进行对应的hash取余来决定定位到哪个节点。
  
  缺点：redis的连接不能扩展，扩容很麻烦，需要重新hash。
  ```

  

- redis cluster

  ```
  可以使用多主多从，提供数据分片功能：（16384）。当写入压力很大的时候，哨兵机制是无法支持的，需要用到redis的集群模式。多个主节点，可以进行负载均衡，根据相应的hash算，来存入不同的槽位。
  
  支持动态扩容，hash槽算法可以很大层度降低数据的失效。比如一开始是三个主节点，
  0-三分之一*16384分配给A节点
  三分之一*16384-三分至二*16384分配给B节点
  三分之二-16384分配给C节点
  那么如果增加一个节点D，则只需要将A,B,C三个节点的槽位匀一部分给D即可。那么失效的数据也就是四分之一而已
  如果减少一个节点C,那么只需要将节点C的槽位匀给A,B节点即可。此时相当于没有失效数据。
  ```

  

  

## 12、如何在海量数据中查找某个key

- keys  xxx*

  ```
  查出所有满足的数据
  
  redis的单线程，因为keys的时间复杂读为O(N),如果数据量太大，可以导致服务出现家假死现象。
  ```

  

- scan 

  ```
  scan 0 xxx* count 5000
  
  元素可能会被返回多次，需要客户端去重。
  在遍历的过程中，被修改的元素不能保证被查出来。
  ```

  



## 13、redis持久化的策略

- RDB

  ```
  内存快照，全量的方式，恢复数据比较快。这个如果出现宕机，那么会丢失一部分数据。
  
  全量写入的方式提供两种， 一个是save,  一种是bgsave
  save: 客户端显示触发，或者是shutdown时触发，单线程，会阻塞其他操作
  bgsave: 客户端显示触发，定时任务触发，主从的从节点触发。fork一个子进程，快照的持久化完全交给子进程。
  ```

  

- AOF

  ```
  连续备份的文件，记录的是操作日志，进行恢复的时候，只要重新操作命令即可，需要
  比较长的时间，如果长期运行，那么AOF的文件会非常大，redis对此提供了rewrite
  机制对日志文件进行瘦身。
  
  触发策略：
  second： 每秒一次fsyn，会由一秒数据的丢失
  no: 由操作系统决定落地，在操作系统落地点的数据可能会丢失
  always: 每次执行命令都fsyn一次： 会降低redis的吞吐量
  ```

  

- 混合

  ```
  4.0之后redis提供了混合方式，先bgsave一分数据，后续的写入通过fsync记录。
  恢复的时候，先执行RDB部分，后执行AOF。即解决了RDB丢失数据的问题，也解决了AOF重启效率的问题。
  ```

  